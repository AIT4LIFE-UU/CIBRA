#source("./help_functions.R")

#' Computationally identify biologically relevant alterations
#'
#' `run_CIBRA` calculates an impact score from provided expression data and
#' defined definitions
#'
#' @param data RNA count dataframe with genes as rows and samples as columns
#' @param definition_matrix design dataframe of the comparisons to make, binary
#'   columns (factors) with an indication of the groups to test and samples as rownames.
#' @param columns columns from the definition_matrix to assess with respect to
#'   the control definition
#' @param control_definition Definition term that will be used as reference for
#'   the comparison (e.g. WT)
#' @param confidence alpha threshold to calculate the proportion (default is 0.1)
#' @param iterations number of iterations for random permutation (recommendation is 50 iterations per definition)
#' @param covariates list of column names from the definition matrix to use as covariates (supported only with DESeq2)
#' @param method method to use for differential expression analysis.
#' options: 'DESeq2', 'edgeR' and 'limma'.
#' Defaults to 'DESeq2'
#' @param parallel boolean state to operate in parallel mode. Defaults to
#'   `FALSE`
#' @param speedup boolean state to run DESeq2 in speedup mode. Defaults to
#'   `FALSE`
#' @param min_n minimal number of samples to consider for analysis. Defaults to
#'   the recommended minimum number of samples: `10`
#' @param outputDir path for result files, if `FALSE`, no results will be
#'   written. Defaults to `FALSE`
#' @param sample_column name of the column containing the sample names, if NULL, rownames will be used
#'
#' @return returns a list containing a dataframe with the signal measures and
#'   associated metadata and associated results generated by differential
#'   expression analysis
#' @export
#'
#' @examples
#'
#' require(dplyr)
#'
#' # load transcription data and genomic alterations
#' count_data <- CIBRA::TCGA_CRC_rna_data
#' mutation_profile <- CIBRA::TCGA_CRC_non_silent_mutation_profile
#'
#' # select BRAF as example
#' goi <- c("BRAF", "APC", "TP53")
#'
#' # filter mutation profile for only selected genes
#' definition_matrix <- mutation_profile[goi]
#'
#' # select only 30 samples for the cases (BRAF mutant) and controls (BRAF WT) for the sake of speed of the example
#' # you can remove this limit if you want to run the full comparison
#'
#' definition_matrix <- definition_matrix %>% tibble::rownames_to_column('sample') %>% group_by(BRAF) %>% sample_n(30) %>% tibble::column_to_rownames('sample')
#'
#' #' # fix sample names for intersect between the two datatypes
#' rownames(definition_matrix) <- stringr::str_replace_all(rownames(definition_matrix), "-", ".")
#'
#' # select intersect between definition matrix and count data
#' sample_list <- intersect(rownames(definition_matrix), colnames(count_data))
#'
#' # select data and definition matrix as the intersect
#' count_data <- count_data[sample_list]
#' definition_matrix <- definition_matrix[sample_list,]
#'
#' # select BRAF
#' columns <- c("BRAF") # if more column were provided in the definition_matrix
#'
#' # set up parameters for CIBRA
#' control_definition <- "WT" # reference condition
#'
#' confidence <- 0.1 # confidence threshold for the proportion calculation
#'
#' # set permutation to 0 to skip permutations
#'
#' iterations = 0 # number of permutation iterations to be performed per condition
#'
#' # register(SnowParam(2)) # set number of cores to be used for parallel processing
#'
#' # run CIBRA with default DE analysis method (DESeq2)
#'
#' CIBRA_res <- run_CIBRA(count_data, as.data.frame(definition_matrix), columns = columns, control_definition = control_definition, confidence = confidence, iterations = iterations, parallel = FALSE) # set parallel to TRUE for parallel processing
#'
#' # calculate the pvalue by comparing to a reference distribution generated with DESeq2
#' perm_data <- CIBRA::perm_dist_crc_tcga
#'
#' # use the gamma test to also calculate a fitted p-value
#' CIBRA_res_stat <-  permutation_test(CIBRA_res$CIBRA_results, perm_data, test = "gamma")
#'
#' @import DESeq2
#' @import edgeR
#' @import limma
#' @import dplyr
#' @import BioNet
run_CIBRA <- function(data,
                      definition_matrix,
                      columns,
                      control_definition,
                      confidence=0.1,
                      iterations=0,
                      covariates = c(),
                      method = "DESeq2",
                      parallel = FALSE,
                      speedup = FALSE,
                      min_n = 10,
                      outputDir = FALSE,
                      sample_column=NULL) {

  # match data sample names and definition matrix
  if (is.null(sample_column)) {
    samples = intersect(colnames(data), rownames(definition_matrix))
    data = data[samples]
    definition_matrix = definition_matrix[samples, , drop=FALSE]
  } else {
    samples = intersect(colnames(data), definition_matrix[[sample_column]])
    data = data[samples]
    definition_matrix = definition_matrix[definition_matrix[[sample_column]] %in% samples,
                                          , drop=FALSE]
  }

  for (column in columns){
    # select column with definitions
    col_covariate <- c(column, covariates, sample_column)
    group = definition_matrix[col_covariate]
    column_group = definition_matrix[column]
    # determine definitions to assess
    investigated_groups = unique(column_group[column_group != control_definition])

    # perform test for each definition
    print(investigated_groups)
    for (investigated_group in investigated_groups){
      print(c(column, investigated_group))

      # select test data
      if (is.null(sample_column)) {
      test_group = dplyr::filter(group, get(column) %in% c(investigated_group,
                                                           control_definition))
      } else {
        test_group = dplyr::filter(group, get(column) %in% c(investigated_group,
                                                              control_definition))
        rownames(test_group) = test_group[[sample_column]]
        test_group[[sample_column]] = NULL
      }
      test_data = data[rownames(test_group)]

      # store metadata of the definition
      n_groups = table(test_group[column])
      n_control = n_groups[[control_definition]]
      n_cases = n_groups[[investigated_group]]

      # Perform only the test if the cases and control are more than the minimum
      # required sample size (default = 10)
      if (n_cases > min_n & n_control > min_n) {

        # perform differential expression analysis
        if (tolower(method) == "deseq2") {
          res =
            DESeq2_test(
              test_data,
              column,
              test_group,
              reference = control_definition,
              parallel = parallel,
              speedup = speedup,
              covariates = covariates
            )
        } else if (tolower(method) == "limma") {
          res = Limma_v_test(test_data,
                              column,
                              test_group,
                              reference = control_definition)
        } else if (tolower(method) == "edger") {
          res = edgeR_test(test_data,
                           rownames(test_data),
                           test_group,
                           reference = control_definition)
        }

        # calculate signal measures (proportion and significant area)
        res_pvals = res$pvalue

        # filter non finite pvalues
        finite_values = is.finite(res_pvals)
        res_pvals = res_pvals[finite_values]
        names(res_pvals) = rownames(res[finite_values,])
        sign_measures =
          signal_measures(res_pvals,
                          confidence,
                          gene = column,
                          cond = investigated_group,
                          outputDir = outputDir)

        # perform n (iterations) random permutations if n > 0
        if (iterations > 0) {
          print("Randomization")
          # calculate signal measures of permuted data
          sign_measures_rand =
            randomization(
              data,
              n_cases,
              n_control,
              iterations = iterations,
              confidence = confidence,
              case = investigated_group,
              control = control_definition,
              parallel = parallel, method = method
            )

          # store results in dataframe
          comp_res = cbind(
            def = investigated_group, # definition tested
            col = column, # name of definition column
            proportion = sign_measures[[1]], # signal measure (proportion)
            sign_area = sign_measures[[2]], # signal measure (significant area)
            # save the group numbers
            investigated = n_cases, #  number of cases tested
            control = n_control, # number of controls used
            # random signal measures with the tested case/control size
            proportion_rnd_avg = sign_measures_rand[1],
            proportion_rnd_sd = sign_measures_rand[2],
            sign_area_rnd_avg = sign_measures_rand[3],
            sign_area_rnd_sd = sign_measures_rand[4],
            iterations = iterations
          )
        } else {
          # store results in dataframe
          comp_res = cbind(
            def = investigated_group, # definition tested
            col = column, # name of definition column
            proportion = sign_measures[[1]], # signal measure (proportion)
            sign_area = sign_measures[[2]], # signal measure (significant area)
            # save the group numbers
            investigated = n_cases, #  number of cases tested
            control = n_control, # number of controls used
            # no permutation performed, so values are NA
            proportion_rnd_avg = NA,
            proportion_rnd_sd = NA,
            sign_area_rnd_avg = NA,
            sign_area_rnd_sd = NA,
            iterations = iterations
          )
        }

        # store extra produced data from the differential expression analysis
        pval_res =
          data.frame(res$pvalue, row.names = rownames(res))
        colnames(pval_res) =
          paste0(column, "_", investigated_group)
        padj_res =
          data.frame(res$padj, row.names = rownames(res))
        colnames(padj_res) =
          paste0(column, "_", investigated_group)
        fc_res =
          data.frame(res$log2FoldChange, row.names = rownames(res))
        colnames(fc_res) =
          paste0(column, "_", investigated_group)

        # if a storage object exists add the results to the storage object
        if (exists("DESeq2_results")) {
          DESeq2_results = rbind(DESeq2_results, comp_res)
          pval_mat = merge(pval_mat, pval_res, by = 0, all = TRUE)
          rownames(pval_mat) = pval_mat$Row.names
          pval_mat$Row.names = NULL
          fc_mat = merge(fc_mat, fc_res, by = 0, all = TRUE)
          rownames(fc_mat) = fc_mat$Row.names
          fc_mat$Row.names = NULL
          padj_mat = merge(padj_mat, padj_res, by = 0, all = TRUE)
          rownames(padj_mat) = padj_mat$Row.names
          padj_mat$Row.names = NULL
          if (iterations > 0) {
            perm_data = rbind(perm_data, sign_measures_rand[[5]])
          }
        } else { # create storage object for the results
          DESeq2_results = comp_res
          pval_mat = pval_res
          fc_mat = fc_res
          padj_mat = padj_res
          if (iterations > 0) {
            perm_data = sign_measures_rand[[5]]
          } else {
            perm_data = NA
          }
        }
      } else {
        print("number of cases < 10")
      }
      gc()
    }
  }
  # create a list to store the CIBRA generated results
  if (exists("DESeq2_results")) {
    CIBRA_results =
      list(
        CIBRA_results = DESeq2_results,
        pvalue_results = pval_mat,
        fc_results = fc_mat,
        padj_results = padj_mat,
        perm_results = perm_data
      )
    return(CIBRA_results)
  } else {
    print("no results")
    return("none")
  }
}

#' Generate CIBRA impact score permutation distribution
#'
#' @inheritParams run_CIBRA
#' @param case_list vector of number of cases to test (vector)
#' @param control_list vector of number of controls to test (vector)
#' @param iterations number of interations (int)
#' @param covariates list of column names from the definition matrix to use as covariates (supported only with DESeq2)
#' @param parallel boolean status if the run should be done in parallel (boolean)
#' @param method method to perform the differential expression analysis, supported methods are DESeq2, edgeR and limma
#' @param permutation permutation style to perform, either full where all values
#' in the matrix are permuted or sample if only the samples should be permuted.
#'
#' @return list of permutation results (dataframe), p-value, adjusted p-value
#' and foldchange generated from the DE analysis from the permutations
#' @export
#'
#' @examples
#'
#' # load transcriptomics data
#' count_data <- CIBRA::TCGA_CRC_rna_data
#'
#' # subset sample to have a quicker run-time for the example
#' count_data <- count_data[,1:50]
#'
#' # set parameters for the reference distribution
#' control_definition <- "NO_SNV"
#' confidence <- 0.1 # use the same confidence as used in standard analysis
#' iterations <- 9 # recommended are at least 1000 permutations to explore the full space
#'
#' # create lists of different case and control sizes
#' case_list <- seq(10, ncol(count_data), length.out = 3) # recommended value is at least 20 different case and control values
#' control_list <- seq(10, ncol(count_data), length.out = 3)
#'
#' # run permutation screen
#' CIBRA_res <- generate_permutation_dist(data = count_data, case_list = case_list, control_list = control_list, control_definition = control_definition, confidence = confidence, iterations = iterations, parallel = FALSE, permutation = "sample")
#'
#' @import dplyr
#' @import DESeq2
#' @import limma
#' @import edgeR
#' @import BioNet
generate_permutation_dist <- function(data,
                                 case_list,
                                 control_list,
                                 control_definition,
                                 confidence,
                                 iterations,
                                 covariates = c(),
                                 covariate_matrix = NULL,
                                 parallel = FALSE, method = "DESeq2",
                                 permutation = "full") {


  #require(utils)
  if (!is.null(covariate_matrix)) {
    samples = intersect(make.names(colnames(data)), make.names(rownames(covariate_matrix)))
    data = data[samples]
    rownames(covariate_matrix) = make.names(rownames(covariate_matrix))
    covariate_matrix = covariate_matrix[samples,]
  }

  # create our grid search matrix from the case and control values
  case_control_grid =
    expand.grid(n_case = case_list, n_control = control_list)
  # the assessed grid values should lie within the bounds of the data
  case_control_grid =
    case_control_grid[rowSums(case_control_grid) <= ncol(data), ]
  round_iterations = iterations / dim(case_control_grid)[1]
  if (round_iterations < 1) {
    round_iterations = 1
  } else {
    round_iterations = round(round_iterations)
  }

  # iterate through the case/control grid to calculate the CIBRA impact score
  for (i in 1:nrow(case_control_grid)) {
    case = case_control_grid[i, "n_case"]
    control = case_control_grid[i, "n_control"]
    print(paste0("testing: ", case, "and ", control))

    # calculate n number of randomly permuted signal measures given the number of cases and controls
    tryCatch({
      sign_measures_rand =
        randomization(
          data,
          case,
          control,
          iterations = round_iterations,
          confidence = confidence,
          case = "random",
          control = control_definition,
          parallel = parallel,
          method = method,
          permutation = permutation,
          covariates = covariates,
          covariate_matrix = covariate_matrix
        )

      # append the result data
      if (exists("perm_data")) {
        perm_data = rbind(perm_data, sign_measures_rand[[5]])

        pval_res = sign_measures_rand[[6]]
        colnames(pval_res) = paste0(colnames(pval_res), "_", i)
        padj_res = sign_measures_rand[[7]]
        colnames(padj_res) = paste0(colnames(padj_res), "_", i)
        fc_res = sign_measures_rand[[8]]
        colnames(fc_res) = paste0(colnames(fc_res), "_", i)

        pval_data = merge(pval_data, pval_res, by = 0, all = TRUE)
        rownames(pval_data) = pval_data$Row.names
        pval_data$Row.names = NULL
        fc_data = merge(fc_data, fc_res, by = 0, all = TRUE)
        rownames(fc_data) = fc_data$Row.names
        fc_data$Row.names = NULL
        padj_data = merge(padj_data, padj_res, by = 0, all = TRUE)
        rownames(padj_data) = padj_data$Row.names
        padj_data$Row.names = NULL
      } else {
        perm_data = sign_measures_rand[[5]]
        pval_data = sign_measures_rand[[6]]
        colnames(pval_data) = paste0(colnames(pval_data), "_", i)
        padj_data = sign_measures_rand[[7]]
        colnames(padj_data) = paste0(colnames(padj_data), "_", i)
        fc_data = sign_measures_rand[[8]]
        colnames(fc_data) = paste0(colnames(fc_data), "_", i)
      }
      print(paste0("Done with cases: ", case, ", controls: ", control))
    }, error = function(e) {
      print(e)
    })
  }
  # return the permuted signal measures and the corresponding DE analysis results
  return(list(perm_data = perm_data, pval_data = pval_data, padj_data = padj_data, fc_data = fc_data))
}

#' CIBRA impact score permutation test
#'
#' @param results observations dataframe returned by CIBRA_run
#' @param perm_dist permutation dataframe returned by generate_permutation_dist
#' @param test either 'perm' for permutation test or 'gamma' for gamma fitted permutation test
#'
#' @return if test: gamma, list of elements results (dataframe of permutation results),
#' fit_proportion: gamma fitted function for the proportion and fit_sign_area:
#' gamma fitted function for the significant area.
#' Else if test: perm, only a dataframe of the results.
#' @export
#'
#' @examples
#' # See example run_CIBRA
#'
#' @import dplyr
#' @import fitdistrplus
#' @importFrom stats pgamma
permutation_test <- function(results, perm_dist, test = "perm") {
  results = as.data.frame(results)

  # storing variables for the p-values
  perm_test_prop = c()
  perm_test_area = c()
  # iterate through the result values and assess the observed measure against the permutation distribution
  for (i in 1:dim(results)[1]) {
    # select proportion and significant area values from the results
    mu_prop = as.numeric(results$proportion[i])
    mu_area = as.numeric(results$sign_area[i])
    # calculate the fraction of values higher in the permutation distribution vs the observed measure
    perm_test_prop[i] =
      (perm_dist %>% dplyr::filter(proportion > mu_prop) %>% dplyr::count())$n /
      dim(perm_dist)[1]
    perm_test_area[i] =
      (perm_dist %>% dplyr::filter(significant_area > mu_area) %>% dplyr::count())$n /
      dim(perm_dist)[1]
  }
  results =
    results %>% dplyr::bind_cols(perm_test_prop = perm_test_prop) %>%
    dplyr::bind_cols(perm_test_area = perm_test_area)

  # if test is "gamma", fit a Gamma distrution to the permutation data and calculate the significance with the Gamma distribution
  if (test == "gamma"){
    # assign NA to invalid values significant area
    perm_dist$cor_sign_area = as.numeric(perm_dist$significant_area)
    perm_dist[perm_dist$significant_area == 0, "cor_sign_area"] = NA

    # fit proportion
    fit_proportion = fitdistrplus::fitdist(as.numeric(perm_dist$proportion), distr = "gamma")

    # fit sign area
    fit_sign_area = fitdistrplus::fitdist(as.numeric(perm_dist$cor_sign_area[!is.na(perm_dist$cor_sign_area)]),
                                          distr = "gamma")

    # calculate pvalues with the fitted estimates
    pvalue_prop = pgamma(as.numeric(results$proportion), shape = fit_proportion$estimate[["shape"]],
                         rate = fit_proportion$estimate[["rate"]], lower.tail = FALSE)
    pvalue_area = pgamma(as.numeric(results$sign_area), shape = fit_sign_area$estimate[["shape"]],
                         rate = fit_sign_area$estimate[["rate"]], lower.tail = FALSE)

    # add new data to results
    results$pvalue_prop = pvalue_prop
    results$pvalue_sign_area = pvalue_area

    # return results and the fitted distributions
    return(list(results = results, fit_proportion = fit_proportion,
                fit_sign_area = fit_sign_area))
  } else {
    return(results)
  }
}

#' CIBRA similarity score
#'
#' `similarity_measures` calculates the categorical similarity scores between
#' two genomic alterations in terms of their expressional profile
#'
#' @param data1 dataframe with the columns pval (-log10 transformed adjusted pvalues from the DE analysis),
#' fc (foldchange from the DE analysis) and type indicating the condition name.
#' @param data2 the same as data1 for the second condition
#' @param plotDir directory path for the figures generated
#' @param cond1 name of condition 1 to be used in the figures
#' @param cond2 name of condition 2 to be used in the figures
#' @param abs_perm_dist absolute permutation distribution of the distance score generated as shown in vignette xxx
#' @param perm_dplus dplus permutation distribution generated as shown in vignette "CIBRA similarity score"
#' @param perm_dmin dmin permutation distribution generated as shown in vignette "CIBRA similarity score"
#' @param perm_mode Boolean to indicate if the similarity_measures should be calculated for a permutation distribution.
#' in this mode, no figures will be generated. only data1 and data2 are needed as input for this mode
#'
#' @return Returns a list containing the calculated spearman correlation (rho),
#' the similarity score (dplus), the anti-similarity score (dmin), the
#' genes associated to the similarity score (dplus_genes) and the genes associated with the
#' anti-similarity score (dmin_genes). It also generates figures
#' @export
#'
#' @examples
#' # generate permutation similarity measures from the permutation distribution generated for the CIBRA impact score
#' permutation_adj_pvalue <- CIBRA::permutation_adj_pvalue
#' permutation_foldchange <- CIBRA::permutation_foldchange
#'
#' # transform the pvalues
#' trans_pvalues <- -log10(permutation_adj_pvalue)
#'
#' rho_list <- c()
#' Dplus_list <- c()
#' Dmin_list <- c()
#'
#' # generate 100 permutation similarity scores (recommended to atleast do 1000 permutations)
#' for (i in 1:100) {
#' # sample colnames to compare two random samples
#' col.sets <- sample(colnames(permutation_foldchange),1)
#' col2.sets <- sample(colnames(permutation_foldchange), 1)
#'
#' # prepare data for diss score calculation
#' data1 <- data.frame(genes = rownames(permutation_foldchange), pval = trans_pvalues[[col.sets]], fc = permutation_foldchange[[col.sets]], type = col.sets)
#' data2 <- data.frame(genes = rownames(permutation_foldchange), pval = trans_pvalues[[col2.sets]], fc = permutation_foldchange[[col2.sets]], type = col2.sets)
#' # similarity score
#' scale_d = similarity_measures(data1, data2, perm_mode = TRUE)
#' Dplus_list <- c(Dplus_list, scale_d$dplus)
#' Dmin_list <- c(Dmin_list, scale_d$dmin)
#' rho_list <- c(rho_list, scale_d$rho)
#' }
#'
#' # read pvalue and fc data for gene of interest (APC exons in this example)
#' pvalues <- CIBRA::APC_definition_padj_values
#' fc <- CIBRA::APC_definition_foldchange
#' trans_pvalues <- -log10(pvalues)
#'
#' # set variables for the permutation distributions
#' perm_dist <- rho_list
#' perm_dplus <- Dplus_list
#' perm_dmin <- Dmin_list
#'
#' # one sided test for the correlation measure
#' abs_perm_dist <- abs(perm_dist)
#' abs_perm_dist <- abs_perm_dist[!is.na(abs_perm_dist)]
#'
#' # select data of the exons of interest, in this example exon 7 and 16 will be compared
#' APC_exon_16 <- data.frame(genes = rownames(fc), pval = trans_pvalues$Transcript.APC.201_X16, fc = fc$Transcript.APC.201_X16, type = "APC exon 16")
#' APC_exon_7 <- data.frame(genes = rownames(fc), pval = trans_pvalues$Transcript.APC.201_X7, fc = fc$Transcript.APC.201_X7, type = "APC exon 7")
#'
#' apc_res <- similarity_measures(data1 = APC_exon_7, data2 = APC_exon_16, cond1 = stringr::str_replace_all(unique(APC_exon_7$type), " ", "_"), cond2 = stringr::str_replace_all(unique(APC_exon_16$type), " ", "_"), abs_perm_dist = abs_perm_dist, perm_dplus =  perm_dplus, perm_dmin = perm_dmin)
#'
#' @import ggplot2
#' @import ggpmisc
#' @import ggthemes
#' @import data.table
#' @import stringr
#' @import tidyverse
#' @import hrbrthemes
#' @import circlize
#' @import ComplexHeatmap
#' @importFrom grDevices dev.off pdf
similarity_measures <- function(data1, data2, plotDir="", cond1="cond1", cond2="cond2", abs_perm_dist=NULL,
                                perm_dplus=NULL, perm_dmin=NULL, perm_mode = FALSE) {
  #ToDO include check if permutation data is provided when perm_mode is FALSE

  if (perm_mode) {
    diss_corr = dissimilarity_correlation(data1, data2,
                                          outputName = paste0(plotDir, cond1, "_",
                                                              cond2,
                                                              "_SNVs_diss_corr_plot.pdf"),
                                          cond1 = cond1, cond2 = cond2,
                                          perm_mode = perm_mode)

  } else {
  # create plot data from the two dataframes
  plot_data = rbind(data1, data2)



  # calculate the correlation dissimilarity score
  diss_corr = dissimilarity_correlation(data1, data2,
                                        outputName = paste0(plotDir, cond1, "_",
                                                            cond2,
                                                            "_SNVs_diss_corr_plot.pdf"),
                                        cond1 = cond1, cond2 = cond2,
                                        perm_dist = abs_perm_dist,
                                        perm_dplus, perm_dmin)


  # calculate the pvalue
  pval = sum(abs(diss_corr$rho) < abs_perm_dist) / length(abs_perm_dist)


  # determine the DE state genes for the similarity visualization and assign the states
  de_state_genes <- data.frame(genes = plot_data$genes, state = NA)
  de_state_genes[de_state_genes$genes %in% diss_corr$dplusgenes, "state"] <- "DEplus"
  de_state_genes[de_state_genes$genes %in% diss_corr$dmingenes, "state"] <- "DEmin"
  de_state_genes[de_state_genes$genes %in% diss_corr$ddissgenes, "state"] <- "DEdiss"

  # plot the similarity volcano plot
  pdf(paste0(plotDir, cond1, "_", cond2, "_SNVs_volcano_link_corr.pdf"))
  vol_p <- volcano_de_state_plot(fc = plot_data$fc, pval = plot_data$pval,
                                 link_column = de_state_genes$genes,
                                 condition_column = plot_data$type,
                                 state_column = de_state_genes$state)
  dev.off()

  ggsave(paste0(plotDir, cond1, "_", cond2, "_SNVs_volcano_link_corr.png"),
         plot = vol_p, dpi = 600, width = 20,
         height = 20,
         units = "cm")

  ggsave(paste0(plotDir, cond1, "_", cond2, "_SNVs_volcano_link_corr_high_res.png"),
         plot = vol_p, dpi = 1200,
         width = 20,
         height = 20,
         units = "cm")
  }

  return(diss_corr)
}
